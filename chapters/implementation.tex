\chapter{Implementation}
\label{cha:implementation}

\epigraph{Ideas are easy, Implementation is hard.}{Guy Kawasaki}

Most of the implementation details and general decisions made for developing a
real-world functional project, based on the design architecture presented in chapter
\ref{cha:architecture}, are discussed in this chapter. It is organized in such a
way that it starts with the foundation and then progresses to the autoscaling of
worker nodes before moving on to example deployments of various applications in the
cluster. \\ %
The technology and programming languages utilized in the implementation are heterogeneous.
Nevertheless, according to a shared set of APIs and pre-defined structures, they
interact as a distinct and homogenous entity that maintains the entire cluster
in an active and healthy state. \\ %
Furthermore, several of the components and/or technologies discussed in this chapter
are interchangeable with other solutions. The latter is highly valuable for
organizations since it provides more configuration freedom and final control
over the cluster while continuously reflecting its ultimate goal.

\section{Distributions}
\label{sec:implementation_distributions}

% TODO Reference introduction dependencies

Almost all software relies on the necessity for a stable and consistent
operating system (OS). \\ %
The OS, as specified in section \ref{subsec:architecture_components_node}, is
installed on every node in the cluster and must be based on the \texttt{Linux
Kernel}. The latter is a critical requirement because most of the technologies
employed in the implementation rely on Linux primitives and core functionality
to operate properly. To enforce resource management for pods and containers, for
example, all Kubernetes distributions require the \texttt{cgroup v2}\footnote{\url{https://www.kernel.org/doc/html/latest/admin-guide/cgroup-v2.html}}
kernel module\footnote{\url{https://kubernetes.io/docs/concepts/architecture/cgroups}}.
Furthermore, the Linux Kernel is an Open Source project to which everyone can
contribute and get access, representing one fundamental objective of the entire project.
\\ %
To represent the potential of the implementation architecture being compatible with
several Linux distributions, the section is titled Distributions rather than
Operating System. A Linux distribution, often known as a Linux distro, is an operating
system that is built from components developed by various open-source projects and
programmers. The Linux kernel (the operating system's core), the GNU shell utilities
(terminal interface and commands), the X server (for a graphical desktop), the desktop
environment, a package management system, an installer, and other services are
all included in each distribution. Many components are created independently and
released in source code format. Thousands of software packages, utilities, and
applications can be found in a single Linux distribution. Linux distributions combine
code from open-source projects into a single operating system that can be installed
and booted. Linux distributions are available for a wide range of specialized
use cases, including desktop computers, servers without a graphical interface, supercomputers,
mobile devices, and more\cite{linux_distro}. \\ %
To be completely compatible with the implementation architecture, a Linux distribution
must meet three major requirements. They are described in the following list:
\begin{enumerate}
  \item The Linux Kernel version must be compatible with the Kubernetes version.
    \newline
    Newer versions of K8s may require newer versions of the Linux Kernel to
    provide newer functions and/or improve overall security.

  \item All necessary packages, as explained and documented in the section
    \ref{subsec:implementation_distributions_packages}, must be installed and globally
    accessible in the system.
    \newline
    A check on all essential packages is performed before the execution of the
    installation program, as detailed in section \ref{sec:implementation_installer}.
    If even one package is missing from the system, the installation fails with an
    error message identifying the missing packages.

  \item An Init System that is supported and compatible, as defined in the
    section \ref{subsec:implementation_distributions_init_system}.
    \newline
    OpenRC and Systemd are supported by the implementation. They are currently
    the two most used init systems, and the majority of available distributions are
    based on one of them.
\end{enumerate}
Finally, two custom Linux distributions are already configured, built, and
packaged as ISO files, as shown in section \ref{subsec:implementation_distributions_iso_image}.
They are based on a simple command line with no graphical interface and contain
only what is required to start a node. This is done to simplify the overall setup
by eliminating unnecessary software and technologies, addressing any
incompatibilities, and increasing the cluster's implementation and testing efficiency.
Both are derived from pre-existing Linux distributions that are known to be
stable, easy to configure, and lightweight, requiring just the bare minimum of resources
to operate. Furthermore, they are built on separate init systems, requiring the
overall implementation to be compatible with and tested with both.

\subsection{Packages}
\label{subsec:implementation_distributions_packages}

The packages used in the implementation that must be available in a Linux distribution
are specified in this section. A package is a collection of files that have been
bundled together and may be installed and uninstalled as a group\cite{package_manager}.
\\ %
All packages may be installed automatically using the package manager of the respective
Linux distribution. A package manager's job is to provide an interface that
assists the user in managing the collection of packages installed on the system.
A package manager maintains track of what software is installed on the system and
makes it simple to install new software, update software to newer versions, or delete
previously installed software. A package is usually a single piece of software. However,
it is typical for applications to be made up of numerous dependent packages. For
example, the \texttt{jq} package includes not just the \texttt{jq} command-line
JSON processor, but also the \texttt{oniguruma}\footnote{\url{https://github.com/kkos/oniguruma}}
package, a regular expressions library. Furthermore, various optional add-on packages
including extra data and documentation are available\cite{package_manager}. \\ %
All packages are already included by default in the two custom Linux
distributions. As a result, there is no need for any changes or the installation
of extra packages. \\ %
Each package in table \ref{tbl:packages} contains a brief description extracted
from its official documentation, as well as some notes on why it was utilized.
Furthermore, the required column indicates with symbols if the package is required
(\textcolor{bulmagreen}{\faicon{check}}), optional (\textcolor{bulmablue}{\faicon{question}}),
or not required (\textcolor{bulmared}{\faicon{times}}). It should be noted that the
name of some packages may differ based on the package manager employed by the Linux
distribution.

\begin{xltabular}
  {\textwidth} { >{\ttfamily}l | c | X | X }

  \multicolumn{1}{ c |}{\large{\textbf{Name}}} &
  \multicolumn{1}{ c |}{\large{\textbf{Required}}} &
  \multicolumn{1}{ c |}{\large{\textbf{Description}}} &
  \multicolumn{1}{ c }{\large{\textbf{Notes}}} \\ \hline \hline

  coreutils\footnote{\url{www.gnu.org/software/coreutils}} & \textcolor{bulmagreen}{\faicon{check}}
  & The GNU Core Utilities are the GNU\footnote{\url{https://www.gnu.org}}
  operating system's essential file, shell, and text manipulation utilities. These
  are the core utilities that are required to be included in any operating system.
  & By default, minimal Linux distributions only include a portion of the massive
  list of utilities provided in the standard \texttt{coreutils} package. As a result,
  several of the applications utilized in the implementation are missing. Therefore,
  the whole \texttt{coreutils} package is required. \\ \hline

  ethtool\footnote{\url{https://www.kernel.org/pub/software/network/ethtool}} & \textcolor{bulmagreen}{\faicon{check}}
  & \texttt{ethtool} is a standard Linux software for managing network drivers and
  hardware by modifying Network Interface Controller (NIC) settings. & If the
  node's NIC interface supports Wake-on-Lan (WoL), \texttt{ethtool} is used to
  activate it.
  \newline
  It's worth noting that the NIC interface may reset to factory settings following
  a reboot. As a result, \texttt{ethtool} is always run before the NIC interface
  is activated. \\ \hline

  inotify-tools\footnote{\url{https://github.com/inotify-tools/inotify-tools}} &
  \textcolor{bulmagreen}{\faicon{check}} & Monitor one or more files or directories
  for a predefined set of events, such as open, close, move/rename, delete or create.
  Under the hood, to be more efficient, it makes use of Linux's \texttt{inotify}\footnote{\url{https://docs.kernel.org/filesystems/inotify.html}}
  interface. & Obtaining access information to the underlying Kubernetes cluster
  is required during the cluster initialization phase. This information is only available
  in an automatically generated configuration file saved in a specific and well-known
  directory. As a result, before proceeding to the next phase, the installation
  script uses the \texttt{inotifywait} program to wait for the file to be created.
  \\ \hline

  iproute2\footnote{\url{https://wiki.linuxfoundation.org/networking/iproute2}} &
  \textcolor{bulmagreen}{\faicon{check}} & \texttt{iproute2} is a collection of utilities
  for managing TCP/IP\footnote{\url{https://wikipedia.org/wiki/Internet_protocol_suite}}
  networking and traffic control in Linux.
  \newline
  The most essential tools are \texttt{ip} and \texttt{tc}. IPv4 and IPv6 configuration
  is handled by \texttt{ip}, whereas \texttt{tc} stands for traffic control. & During
  the installation phase, the command \texttt{ip} is used to gather information about
  physical network interfaces that are not \texttt{loopback}\footnote{\url{https://wikipedia.org/wiki/Loopback}},
  such as name and MAC address. \\ \hline

  jq\footnote{\url{https://stedolan.github.io/jq}} & \textcolor{bulmagreen}{\faicon{check}}
  & \texttt{jq} is a lightweight and flexible command-line JSON\footnote{\url{https://www.json.org}}
  processor. & To manipulate JSON data, all scripts make extensive use of \texttt{jq}.
  \\ \hline

  ncurses\footnote{\url{https://invisible-island.net/ncurses}} & \textcolor{bulmared}{\faicon{times}}
  & The \texttt{ncurses} (new curses) library is a free software emulation of
  curses in System V\footnote{\url{https://wikipedia.org/wiki/UNIX_System_V}}. It
  supports pads, color, multiple highlights, forms characters, and function-key mapping,
  as well as all of the other SVr4-curses improvements over BSD curses. & The \texttt{ncurses}
  package includes the \texttt{tput} software, which is a utility for retrieving
  terminal capabilities in shell scripts.
  \newline
  When the spinner process is spawned in a script, \texttt{tput} is used to update
  its symbols at regular intervals, replacing the old one with the new one and
  updating the cursor position. Because a spinner is only a decorative element,
  the package is not required and can be omitted. \\ \hline

  nodejs\footnote{\url{https://nodejs.org/en}} & \textcolor{bulmablue}{\faicon{question}}
  & Node.js is an open-source, cross-platform JavaScript\footnote{\url{https://developer.mozilla.org/docs/Web/JavaScript}}
  runtime environment. & This package is optional since the Server component,
  see section \ref{subsec:architecture_components_server}, may be bundled as a single
  binary or in a container, removing the need for the \texttt{nodejs} package to
  be installed. Because the present implementation does not provide any of the
  aforementioned alternatives, \texttt{nodejs} is included in both of the two
  custom Linux distributions. \\ \hline

  npm\footnote{\url{https://www.npmjs.com}} & \textcolor{bulmablue}{\faicon{question}}
  & The package manager for the Node.js JavaScript platform. It installs modules
  so that Node.js can locate them and intelligently resolves dependency
  conflicts. It is highly adaptable to serve a wide range of use cases. It is
  often used to publish, find, install, and build node applications. & This
  package is optional since the Server component may be bundled as a single
  binary or in a container, removing the need for the \texttt{npm} package to be
  installed. Because the present implementation does not provide any of the aforementioned
  alternatives, \texttt{npm} is included in both of the two custom Linux distributions.
  \\ \hline

  postgresql\footnote{\url{https://www.postgresql.org}} & \textcolor{bulmablue}{\faicon{question}}
  & \texttt{PostgreSQL} is a powerful, open-source object-relational database
  system with a high reputation for reliability, feature robustness, and
  performance. & \texttt{PostgreSQL} is the database implementation used for the
  Database component (see section \ref{subsec:architecture_components_database}).
  \newline
  This package is optional since the database may be implemented outside of the cluster
  using other solutions. It is up to the organization in charge of the cluster
  to decide whether or not the database package should be included in the Linux
  distribution. \\ \hline

  procps-ng\footnote{\url{https://gitlab.com/procps-ng/procps}} & \textcolor{bulmared}{\faicon{times}}
  & \texttt{procps} is a collection of command-line and full-screen programs
  that offer information from the \texttt{/proc}\footnote{\url{https://docs.kernel.org/filesystems/proc.html}}
  pseudo-filesystem. \texttt{procps} programs often concentrate on the
  structures that describe the processes operating on the system. & The \texttt{procps-ng}
  package includes the \texttt{ps} software, which displays information about
  the system's active processes.
  \newline
  When the spinner process is spawned in a script, \texttt{ps} is used to obtain
  the PID\footnote{\url{https://wikipedia.org/wiki/Process_identifier}} of the parent
  process. Because a spinner is only a decorative element, the package is not required
  and can be omitted. \\ \hline

  sudo\footnote{\url{https://www.sudo.ws}} & \textcolor{bulmagreen}{\faicon{check}}
  & \texttt{sudo} (su\footnote{\url{https://wikipedia.org/wiki/Su_(Unix)}} "do")
  enables a system administrator to delegate authority to allow specific users (or
  groups of users) to run certain (or all) commands as root or another user while
  providing an audit record of the commands and their arguments. \texttt{sudo} works
  on a per-command basis; it is not a shell replacement. & The installation phase
  involves actions that need administrative authorization. Before performing any
  processing, the script checks to see whether the current user already has root\footnote{\url{https://wikipedia.org/wiki/Superuser}}
  privileges; if not, it requests them with \texttt{sudo}. \\ \hline

  sysbench\footnote{\url{https://github.com/akopytov/sysbench}} & \textcolor{bulmagreen}{\faicon{check}}
  & \texttt{sysbench} is a multithreaded scriptable benchmark tool for measuring
  CPU, memory, file I/O, mutex performance, and database performance. & During the
  installation phase, \texttt{sysbench} is extensively used to analyze a cluster
  node's performance and, in conjunction with other tools, its power consumption.
  \\ \hline

  tzdata\footnote{\url{https://www.iana.org/time-zones}} & \textcolor{bulmagreen}{\faicon{check}}
  & The Time Zone Database is a collection of code and data that represents the
  history of local time for several representative locations all over the world.
  It is updated regularly to reflect changes in time zone boundaries, UTC
  offsets, and daylight-saving laws enacted by legislative entities. & To avoid
  date and time inconsistencies, all nodes in the cluster must be configured to the
  same timezone. By default, all nodes are configured to the Etc/UTC timezone.
  \\ \hline

  util-linux\footnote{\url{https://github.com/util-linux/util-linux}} & \textcolor{bulmagreen}{\faicon{check}}
  & \texttt{util-linux} is a random collection of Linux utilities. & The
  installation script makes use of two \texttt{util-linux} utility programs:
  \texttt{lscpu} to display information about the CPU architecture and \texttt{lsblk}
  to list block devices. \\ \hline

  yq\footnote{\url{https://mikefarah.gitbook.io/yq}} & \textcolor{bulmagreen}{\faicon{check}}
  & \texttt{yq} is a portable and lightweight command-line YAML\footnote{\url{https://yaml.org}},
  JSON, and XML\footnote{\url{https://www.w3.org/XML}} processor.
  \newline
  \texttt{yq} has a syntax similar to \texttt{jq}. It does not cover all that
  \texttt{jq} supports, but it does support the majority of the most common
  operations and functions. & To manipulate YAML data, all scripts make
  extensive use of \texttt{yq}.
  \newline
  \texttt{yq} is primarily used to read and save YAML files. However, because of
  its more advanced functions and solutions, \texttt{jq} is used for the majority
  of complex data processing, at the expense of \texttt{yq}. As a result, YAML structures
  are first transformed to/from JSON, then processed with \texttt{jq}, and then
  converted back to/from YAML. The double conversion should be eliminated and/or
  simplified in future implementations. \\ \hline

  \caption{Packages list}
  \label{tbl:packages}
\end{xltabular}

\subsection{Init System}
\label{subsec:implementation_distributions_init_system}

\subsubsection{OpenRC}
\label{subsec:implementation_distributions_init_system_openrc}

\subsubsection{Systemd}
\label{subsec:implementation_distributions_init_system_systemd}

\begin{wrapfigure}
  {r}{.25\textwidth}
  \centering
  \includegraphics[width=.25\textwidth]{images/logos/systemd.png}
  \caption{Systemd logo}
\end{wrapfigure}

\subsection{ISO image}
\label{subsec:implementation_distributions_iso_image}

\subsubsection{Generation}
\label{subsubsec:implementation_distributions_iso_generation}

\subsubsection{Alpine Linux}
\label{subsubsec:implementation_distributions_iso_alpine_linux}

\begin{wrapfigure}
  {r}{.25\textwidth}
  \centering
  \includegraphics[width=.25\textwidth]{images/logos/alpine.png}
  \caption{Alpine Linux logo}
\end{wrapfigure}

Alpine Linux\footnote{\url{https://www.alpinelinux.org}} is a lightweight, security-focused,
and resource-efficient distribution. In recent years, has grown in popularity as
the foundation for the majority of Docker images. It is based on musl\footnote{\url{https://musl.libc.org}}
(an implementation of the C standard library, an alternative to glibc), BusyBox\footnote{\url{https://busybox.net}}
(a single, small executable that combines tiny versions of many common UNIX utilities),
a custom package manager called APK\footnote{\url{https://wiki.alpinelinux.org/wiki/Alpine_Package_Keeper}}
and the OpenRC init system ()\cite{alpine_linux}. \\ % TODO OpenRC reference
Alpine Linux is the preferred reCluster distribution. It has been utilized and
tested during development and is now present in every cluster node.

\subsubsection{Arch Linux}
\label{subsubsec:implementation_distributions_iso_arch_linux}

\begin{wrapfigure}
  {r}{.25\textwidth}
  \centering
  \includegraphics[width=.25\textwidth]{images/logos/arch.png}
  \caption{Arch Linux logo}
\end{wrapfigure}

Arch Linux\footnote{\url{https://archlinux.org}} is a general-purpose
distribution that focuses on simplicity, minimalism, and code elegance. It is based
on Systemd init system () % TODO Systemd reference
and strives to stay bleeding edge, offering the latest stable versions of most
software through Pacman\footnote{\url{https://wiki.archlinux.org/title/Pacman}}
package manager. Uses a rolling release system that allows one-time installation
and perpetual software upgrades, allowing to not reinstall or upgrade the system
from one version to the next. Notably, Arch Linux is the foundation for several
many popular enterprise-grade distributions, such as Manjaro\footnote{\url{https://manjaro.org}}
and SteamOS\footnote{\url{https://store.steampowered.com/steamos}},
demonstrating its customizability, power, and stability\cite{arch_linux}.

\section{Dependencies}
\label{sec:implementation_dependencies}

% TODO Dependencies presentation

\subsection{Air-Gap Environment}
\label{subsec:implementation_dependencies_air_gap_environment}

\subsection{Management}
\label{subsec:implementation_dependencies_management}

\subsubsection{Configuration}
\label{subsec:implementation_dependencies_management_configuration}

\subsubsection{Script}
\label{subsec:implementation_dependencies_management_script}

\subsection{K3s}
\label{subsec:implementation_dependencies_k3s}

\begin{wrapfigure}
  {r}{.25\textwidth}
  \centering
  \includegraphics[width=.25\textwidth]{images/logos/k3s.png}
  \caption{K3s logo}
\end{wrapfigure}

\subsection{Node Exporter}
\label{subsec:implementation_dependencies_node_exporter}

\subsection{Prometheus}
\label{subsec:implementation_dependencies_prometheus}

\begin{wrapfigure}
  {r}{.25\textwidth}
  \centering
  \includegraphics[width=.25\textwidth]{images/logos/prometheus.png}
  \caption{Prometheus logo}
\end{wrapfigure}

\subsection{Autoscaler}
\label{subsec:implementation_dependencies_autoscaler}

\subsubsection{Cluster Autoscaler}
\label{subsec:implementation_dependencies_autoscaler_cluster_autoscaler}

\section{Installer}
\label{sec:implementation_installer}

\subsection{POSIX Shell}
\label{subsec:implementation_installer_posix_shell}

\subsection{Configuration Arguments}
\label{subsec:implementation_installer_configuration_arguments}

\subsection{Configuration Files}
\label{subsec:implementation_installer_configuration_files}

\subsubsection{Certificates}
\label{subsubsec:implementation_installer_configuration_files_certificates}

\subsubsection{K3s}
\label{subsubsec:implementation_installer_configuration_files_k3s}

\subsubsection{K8s}
\label{subsubsec:implementation_installer_configuration_filesn_k8s}

\subsubsection{Node exporter}
\label{subsubsec:implementation_installer_configuration_files_node_exporter}

\subsubsection{reCluster}
\label{subsubsec:implementation_installer_configuration_files_recluster}

\subsubsection{SSH}
\label{subsubsec:implementation_installer_configuration_files_ssh}

\subsection{Node Facts}
\label{subsec:implementation_installer_node_facts}

\subsection{Node Information}
\label{subsec:implementation_installer_node_information}

\subsection{Node Benchmarks}
\label{subsec:implementation_installer_node_benchmarks}

\subsubsection{SysBench}
\label{subsubsec:implementation_installer_node_benchmarks_sysbench}

\subsection{Node Power Consumption}
\label{subsec:implementation_installer_node_power_consumption}

\subsubsection{CloudFree Smart Plug}
\label{subsubsec:implementation_installer_node_power_consumption_cloudfree_smart_plug}

\subsection{Node Registration}
\label{subsec:implementation_installer_node_registration}

\subsubsection{K8s Node Label And Name}
\label{subsubsec:implementation_installer_node_registration_k8s_node_label_and_name}

\subsection{Cluster Initialization}
\label{subsec:implementation_installer_cluster_initialization}

\subsubsection{Kubeconfig}
\label{subsubsec:implementation_installer_cluster_initialization_kubeconfig}

\subsubsection{Database}
\label{subsubsec:implementation_installer_cluster_initialization_database}

\subsubsection{Server}
\label{subsubsec:implementation_installer_cluster_initialization_server}

\subsubsection{Admin And Autoscaler Users}
\label{subsubsec:implementation_installer_cluster_initialization_admin_and_autoscaler_users}

\subsubsection{K8s}
\label{subsubsec:implementation_installer_cluster_initialization_k8s}

\subsection{Services}
\label{subsec:implementation_installer_services}

\subsubsection{Start}
\label{subsubsec:implementation_installer_services_start}

\subsubsection{Stop}
\label{subsubsec:implementation_installer_services_stop}

\subsubsection{Boot}
\label{subsubsec:implementation_installer_services_boot}

\subsubsection{Shutdown}
\label{subsubsec:implementation_installer_services_shutdown}

\section{Server}
\label{sec:implementation_server}

\subsection{Database}
\label{subsec:implementation_server_database}

\subsubsection{PostgreSQL}
\label{subsubsec:implementation_server_database_postgresql}

\begin{wrapfigure}
  {r}{.25\textwidth}
  \centering
  \includegraphics[width=.25\textwidth]{images/logos/postgresql.png}
  \caption{PostgreSQL logo}
\end{wrapfigure}

\subsubsection{Prisma}
\label{subsubsec:implementation_server_database_prisma}

\begin{wrapfigure}
  {r}{.25\textwidth}
  \centering
  \includegraphics[width=.25\textwidth]{images/logos/prisma.png}
  \caption{Prisma logo}
\end{wrapfigure}

\subsubsection{Schema}
\label{subsubsec:implementation_server_database_schema}

\subsection{GraphQL}
\label{subsec:implementation_server_graphql}

\subsubsection{GraphQL vs REST}
\label{subsubsec:implementation_server_graphql_graphql_vs_rest}

\subsubsection{Schema}
\label{subsubsec:implementation_server_graphql_schema}

\subsection{Node Pool}
\label{subsec:implementation_server_node_pool}

\subsection{Node Registration}
\label{subsec:implementation_server_node_registration}

\subsubsection{JSON Web Token}
\label{subsubsec:implementation_server_node_registration_json_web_token}

\subsection{Upscaling}
\label{subsec:implementation_server_upscaling}

\subsubsection{Wake-on-LAN}
\label{subsubsec:implementation_server_scale_up_wake_on_lan}

\subsection{Downscaling}
\label{subsec:implementation_server_downscaling}

\subsubsection{SSH}
\label{subsubsec:implementation_server_scale_up_ssh}

\section{Autoscaling}
\label{sec:implementation_autoscaling}

\subsection{Vertical Pod Autoscaler}
\label{subsec:implementation_autoscaling_vertical_pod_autoscaler}

\subsection{Horizontal Pod Autoscaler}
\label{subsec:implementation_autoscaling_horizontal_pod_autoscaler}

\subsection{Cluster Autoscaler}
\label{subsec:implementation_autoscaling_cluster_autoscaler}

\subsubsection{Cloud Provider}
\label{subsubsec:implementation_autoscaling_cluster_autoscaler_cloud_provider}

\subsubsection{Configuration}
\label{subsubsec:implementation_autoscaling_cluster_autoscaler_configuration}

% TODO Cloud Configuration

\subsubsection{Upscaling}
\label{subsubsec:implementation_autoscaling_cluster_autoscaler_upscaling}

\subsubsection{Downscaling}
\label{subsubsec:implementation_autoscaling_cluster_autoscaler_downscaling}