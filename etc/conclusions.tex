\chapter{Conclusions}
\label{cha:conclusions}

Current cluster architectures are mainly concerned with maximizing service performance
and achieving near-instantaneous responsiveness while ignoring the energy impact
and the various resources involved. As a result, it is becoming more and more necessary
--- almost a requirement --- to reconsider and transform existing designs to create
architectures that are more resource-aware and sustainable. These latter
requirements must be considered just as vital as performance and responsiveness.
\\ %
The context and fundamental principles on which the new and more sustainable
cluster architectures should either completely or partially rely on have been
initially explained in this document. Moreover, due to the outsourcing
phenomenon that shifts local and physical architectures towards remote, intangible,
and virtual architectures, users tend to forget the numerous implications of this
decision that not only can have privacy and/or security concerns but also, and
most importantly in this case, completely removes the direct control and the resource
awareness of the overall system. \\ %
Following the introduction, a possible theoretical design that is more
sustainable has been put forward, prioritizing the reduction of resource waste and
energy consumption while maintaining a certain degree of adaptability and configurability.
Every component that constitutes the architecture has been thoroughly explained,
highlighting its main purpose and different capabilities. A cluster is not a
cluster if the different components are not connected. In the design, there are
three major network groups: K8s, Internal and External; where the External Network
may even be removed if external resources and connections are not required. The
reCluster project, which is a practical and sustainable cluster implementation of
the theorized architecture, has also been presented. All of its hardware components
have been recycled following decommissioning. \\ %
The implementation thoroughly explains how the reCluster was put into practice while
adhering to both the fundamental requirements and the theoretical architecture behind
the networks and components. It begins with the foundations, which are composed of
GNU/Linux, a collection of programs, and the Init System, all of which are
packaged together as a custom distribution into a portable and simple-to-install
ISO image file. Then, each theorized component is mapped to a real-world
application, and some of its most important features used in reCluster are explained.
The way the Server and Cluster Autoscaler components are implemented is
different because the first one was entirely built from scratch, whereas the second
one used an existing core that had been modified to be compatible with the cluster
architecture. The Server component represents the low-level knowledge of the
cluster and is deeply described, including the database structure, GraphQL
queries and mutations API, how the upscaling and downscaling procedures are handled,
and how to exploit Kubernetes monitoring without the need for a custom
implementation. The Cluster Autoscaler, on the other hand, represents the high-level
knowledge of the cluster, and it is used in conjunction with the Server
component to perform the upscaling or downscaling operations. The Cluster Autoscaler
only scales the number of nodes and, because it is not the only method of
autoscaling in a cluster, the other two approaches are also explained: Vertical
Pod Autoscaler, which automatically adjusts the resources of a Pod, and
Horizontal Pod Autoscaler, which automatically adjusts the number of Pods. The
combination of the Horizontal Pod Autoscaler and the Cluster Autoscaler is
critical for improving total automation and minimizing the need for human
intervention, as well as lowering overall power consumption while maintaining scalability.
\\ %
Lastly, because manually installing the cluster and providing all of the
necessary information is tedious, the installation script that automatically performs
the installation operation while following a specific set of configuration parameters
has been discussed and proposed. Moreover, it is demonstrated how the node's benchmarks
and power consumption data are measured. Finally, the most essential elements of
the configuration and deployment files of the various components and/or technologies
used are illustrated and discussed, so that the employed features of each can be
recognized. \\ %
With all of the prior information and technology, building and deploying a more sustainable
and resource-aware cluster is feasible without incurring into breaking trade-offs;
while it may be regarded as a tiny step towards sustainable computing, it, along
with other initiatives, attempts to bring the result closer to realization.

\section{Limitations And Future Work}
\label{sec:conclusions_limitations_and_future_works}

This section depicts some of the difficulties encountered, existing criticalities
and limitations, and relevant future ideas that can enhance and extend the
current architecture and implementation. Because one of the project's main points
is FLOSS (Free/Libre and Open Source Software) compliance, anyone from anywhere
can contribute to it. The latter not only can increase the overall number of features
but also improve overall stability thanks to intrinsic testing in various use-case
scenarios and heterogeneous environments, which allows for the discovery and
correction of previously unknown bugs and/or errors. External contributions from
a wide variety of users are so valuable that they are frequently undervalued and
underestimated in current contexts. \\ %

The combination of the installation script and the external device for measuring
power consumption only conducts simple and basic readings on the instantaneously
drawn energy. This is ideal for desktop computers and servers that require an external
energy source, but it is incompatible with devices that use an internal energy
source (batteries), such as laptop computers. \\ %
If the existing implementation of the installation script is executed on a laptop
computer, the resulting power consumption readings are inaccurate since it does
not take into consideration the current absorbed energy from both the external (plug)
and internal (battery) sources, but only the first. As a result, the obtained final
power consumption data are always lower than what are in reality, leading to
general inefficiency and erroneous selection by the algorithm in upscaling and
downscaling operations, because the Server recognizes the node as a much more power-efficient
system than it is. \\ %
The script should determine whether the current node has internal energy sources
and, when conducting power consumption readings and calculations, adjust with a more
sophisticated but efficient and compatible algorithm that takes into account for
both external and internal absorbed energy. Moreover, further testing on devices
with an internal energy source is required to better understand how the system is
powered, as it can solely use the external source, only use the internal source,
or even employ both. \\ %

Another of the project's most significant difficulties has been developing the recluster
Cloud Provider for the Cluster Autoscaler. There are three primary reasons for
this. \\ %
First off, the Cluster Autoscaler and the majority of the Kubernetes development
environment are built using the Go\footnote{\url{https://go.dev}} programming language.
I had never written a line of Go code before developing the \texttt{recluster} Cloud
Provider, so I had to learn the language from the beginning as well as the
package ecosystem, code style, and syntax. Although difficult at first, the
effort paid off in the end. \\ %
Second, neither official nor unofficial documentation exists that explains how to
create a Cloud Provider for the Cluster Autoscaler. My entire knowledge of
developing the \texttt{recluster} Cloud Provider is based on studying and evaluating
the code developed by the other Cloud Providers. Additionally, because each Cloud
Provider has a unique implementation, distinct Server logic, and a different API,
I had to determine the similarities and fundamental elements that almost all of
them share to transform it and make it compatible with reCluster. The lack of documentation
is understandable given that only a small number of entities utilize and develop
this technology, making it possible for them to access experts and/or
specialized consulting from the main CA developers themselves. Keep in mind that
the latter needs familiarity with the Go programming language, which was covered
in the preceding point. \\ %
Finally, it took longer than I anticipated to test the Cluster Autoscaler in conjunction
with the Server and the general architecture since almost every time a new,
minor error or bug that I hadn't considered appeared. However, the latter was
not only beneficial for reCluster; it additionally helped in identifying an issue\footnote{\url{https://github.com/kubernetes/autoscaler/issues/5378}}
in the Cluster Autoscaler's main code, which was submitted to the maintainers
and promptly fixed within a week. \\ %

Currently, the only way for a user or administrator to interact with the cluster
is to use applications such as \texttt{curl}, \texttt{wget}, or similarities to
directly use the various set of GraphQL queries and mutation API, or use the GraphQL
Studio Explorer, which is not available in production and is only a nicer
interface for low-level interactions with the GraphQL API. As a result, there is
a need to create a UI dashboard, such as the one from Kubernetes\footnote{\url{https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard}},
where all of the information provided by the Server is visually available
without involving the user in low-level GraphQL API interactions. The majority of
operations should be simple and intuitive, without needing the user to better
understand the requirements and outcomes. \\ %
Because the web application must consider the authentication mechanism, only authorized
and/or authenticated users may access specific information or do certain operations.
Furthermore, to provide a better overview of all the information accessible to the
user, the dashboard should be capable of generating faster-to-understand graphs
and/or charts. Consider a pie chart in which the number of active/working nodes (green
color) is visually compared against the number of inactive nodes (gray color).
The user can immediately understand the current cluster capacity/demand, where if
the chart is almost entirely green, there is an overall high workload in the
cluster, whereas if the chart is almost entirely gray, there is an overall low
workload in the cluster, and thus the number of inactive nodes predominates. \\ %
With so many tools, technologies, and frameworks available for developing a web application
nowadays, the most difficult and critical phase is choosing which one to use
before even beginning development. \\ %
Also, there may be a desire to improve the simplicity with which each node is managed
without directly requiring \texttt{SSH} or similar technologies. \\ %
The latter can be accomplished by directly integrating a protected graphical
dashboard on each node that displays the various information of the associated
node as well as the ability to install, upgrade, or delete packages and perform
additional operations. \\ %
\texttt{YunoHost}\footnote{\url{https://yunohost.org}}, which leverages a simple
and easy-to-use, but incredibly powerful, web UI dashboard to completely
administer the node, is a starting point for what may be accomplished or developed.
\\ %

Computers are the only systems that are currently used and supported in the
cluster. But, there are an enormous number of unused smartphone and tablet
devices that might be employed in the cluster. Most of these devices are ideal for
becoming worker nodes in a cluster because the previous owners replaced them due
to an upgrade to a newer model or because there is hardware damage, such as on
the screen or camera, but this has not affected important components such as the
main board. Furthermore, these devices have become so powerful in recent years that
they may be compared to the same performance as medium/low-end PCs while having a
significantly lower power consumption thanks to different internal architecture and
a prior design on energy consumption optimizations. \\ %
Developing for mobile devices might be challenging since there may be incompatibilities
between the software used for the cluster related to the internal Operating System
and missing libraries or Kernel requirements. A viable alternative is to
uninstall the existing operating system (\texttt{Android} or \texttt{iOS}) and
replace it with a pure GNU/Linux distribution designed exclusively for mobile
devices, such as \texttt{postmarketOS}\footnote{\url{https://postmarketos.org}}.
It should be noted that the overall compatibility of the Operating System with the
device varies from device to device, and the OS may need to be patched. Mobile development
should not be hard, however, this is the current status and/or only method for quickly
porting applications designed for GNU/Linux on PCs to mobile devices. \\ %
As previously stated, the power consumption of mobile devices is extremely small
compared to what they can provide. When compared to desktop computers and even laptop
computers, the performance-to-power-consumption ratio is enormous. There are no simple
techniques for remotely powering on a mobile device that does not involve custom
solutions. However, it should be mentioned that the sleep mode of mobile devices
is so efficient that a device in sleep mode consumes almost zero energy and may last
for more than a week on a single charge. As a result, if the remote wake-up solution
is too expensive or unfeasible, the concept of keeping a mobile device
constantly in sleep mode might be considered. \\ %

The cluster currently supports only \texttt{amd64} and \texttt{arm64} architectures.
Because the majority of the employed software and technologies support a wide
range of different architectures by default, such as \texttt{mips}\footnote{\url{https://wikipedia.org/wiki/MIPS_architecture}}
or \texttt{mipsel}, the remaining incompatible components, such as the Cluster Autoscaler,
can be ported and/or transformed to be compatible with additional and different
architectures. \\ %
Expanding the number of supported architectures allows more devices to be
incorporated into the cluster, giving them new life while also improving the cluster's
overall workload capacity. \\ %

The existing Node selection algorithm is effective, but it is a simplistic implementation
because it just depends on maximum and minimum power consumptions and, if both
are identical, falls back to performance data. \\ %
The existing algorithm works, despite its simplicity and limited accessible data
to perform all conceivable computations and evaluations. Nevertheless, there are
several aspects where it may be refined to accomplish a more suitable node's
final decision. As an example, while upscaling, the chosen node may have a lower
power consumption and possibly greater performance, whereas when downscaling, it
may have higher power consumption and potentially worse performance. Furthermore,
in future versions, the more efficient and sophisticated algorithm should take
into consideration other factors with a more advanced internal logic. There may be
nodes that are more efficient while under medium workload conditions, while
others that are less efficient when under the same conditions but with lower
minimum and maximum power consumption coefficients. The existing approach is deterministic,
always preferring the second node type when upscaling and the first node type
when downscaling. The new algorithm should perform extra computations and evaluations
on which node type should bootstrap or terminate, and it's expected to follow
the current overall cluster state as well as its overall power consumption. \\ %
The algorithm may also be enhanced with a Kalman Filter\footnote{\url{https://wikipedia.org/wiki/Kalman_filter}}
for estimating the combination of power consumption and workload to
significantly reduce total (real) power consumption while also improving overall
Quality of Service (QoS). \\ %
The latter are merely possible ideas for what the new enhanced algorithm should
include and what possible advancements, such as lowering power consumption while
increasing overall performance, must be addressed. \\ %

There are no graphs or charts in this document to demonstrate how the generally existing
cluster implementation performs on different workloads and/or hardware. This is
because the time and resources required to conduct such measurements accurately
and precisely are presently insufficient for a single person. \\ %
The cluster's performance management can be proposed as an extra document/paper
that not only illustrates the various data collected, but also enhances and extends
the existing design and algorithms with improvements determined from the performance
management results. This task is currently assigned to another CRIT team member
who employs this document as a foundation to better comprehend how the general
architecture is designed and how to obtain correct and precise performance
measurements. \\ %
Even though this document lacks data on performance measurements, the current cluster
implementation by default exposes data that can be used for analysis of general performance
and resource utilization. Every node in the cluster provides real-time hardware
and OS-related data thanks to the Node Exporter component, which is described in
section \ref{subsec:implementation_dependencies_node_exporter}. These metrics
are then collected and analyzed by the Prometheus component, as described in section
\ref{subsubsec:implementation_dependencies_prometheus_features}, which allows
for monitoring and querying/interpolating them with various results that can
cover a specified period. \\ %
Furthermore, because the overall architecture is already established and deployed
automatically, control of overall performance may be employed not only
occasionally or during testing but always. This not only gives reacher statistics,
but it additionally has the potential to provide real-time alerts on the overall
health of the cluster. Besides that, custom notifications that monitor the total
cluster power consumption can be established. This can be critical in a variety of
use-case situations. Consider the following scenario: the cluster is powered solely
by batteries that are charged during the day by solar panels, similar to the Low-Tech
magazine\footnote{\url{https://solar.lowtechmagazine.com}}, and there is a known
overall threshold amount of energy consumption that, if exceeded, can cause the entire
cluster to go offline until the next recharge. Employing an accurate performance
management system to compute the threshold, as well as a monitoring and alerting
system to notify an administrator, is critical; enabling the cluster to be online
and active as much as possible while also performing its main routine of service
orchestration. \\ %
Nevertheless, this point is critical, and it must be addressed and implemented in
future versions of reCluster. \\ %

In addition to the preceding point, there is a missing section where the various
use-case scenarios are analyzed and tested owing to the same reasons of a single
person's lack of time and resources. \\ %
Currently, only two use-case scenarios have been successfully evaluated in a
real-world context using the reCluster cluster architecture. The first scenario is
a one-to-one mapping to a potential cluster used for hosting various services that
need to be exposed to an external network or, more broadly, the Internet. It has
a stable connection, and most of the components and their configurations may be downloaded,
guaranteeing the most recent and up-to-date versions are used in the cluster. Having
the most recent versions available might be beneficial since there may be bugs or
security vulnerabilities that have been addressed, whereas the bundled ones may
contain issues due to being outdated. The first scenario is the most common, in
which practically anybody can deploy a cluster without difficulty. The second scenario,
on the other hand, is an Air-Gap environment in which there is no Internet connection
and all components and processes must be available and performed offline. The
latter has been well detailed throughout the document, and it may also be regarded
as a solid foundation/requirement for future environmental and availability crises
in which having an internet connection is no longer obvious. Using Air-Gap
measurements only during the installation procedure, while the normal execution is
in normal conditions with an Internet connection, can be advantageous because it
does not require any download, reducing overall installation time and also avoiding
the involvement of networking equipment, which can consume unnecessary energy, and
the installed software behavior is always predictable. \\ %
In addition to the preceding two scenarios, the cluster might be deployed in two
additional scenarios. The first instance is when the cluster may be used in education
to evaluate students' work. The latter can be employed to test their Kubernetes abilities,
as well as teach them basic and advanced web apps or APIs that include various
software components, such as a server, a database, and a cache server. The
second scenario is for redundancy, in which reCluster is being used only if the main
cluster, which is more performant but consumes more energy, is no longer accessible
due to a failure. reCluster uses decommissioned main cluster hardware and has
just one Controller node active, whereas all worker nodes are inactive. If there
is workload that has to be scheduled while the main cluster is unavailable, the worker
nodes start to boot up. It is worth noting that, even if there are hundreds of worker
nodes, the overall power consumption when the main cluster is healthy is that of
the single Controller node, which is negligible. \\ %

\begin{wrapfigure}
  {r}{.25\textwidth} %
  \centering
  \def\stackalignment{r}\stackunder{ \includegraphics[width=\linewidth]{images/logos/rust.png} } %
  {\scriptsize \parbox[t]{\linewidth}{ Source: \url{https://foundation.rust-lang.org/policies/logo-policy-and-media-guide}} }
  \caption{Rust logo}
\end{wrapfigure}

In future releases, the Server implementation may and must be improved. \\ %
Replace any interpreted languages, such as \texttt{JavaScript} or \texttt{Python},
in the Server with a compiled/low-level programming language, such as \texttt{C},
\texttt{C++}, or \texttt{Rust}. Using these programming languages has two major advantages
over the existing implementation. First, because the program must be compiled to
produce the final executable, there is no need to distribute an archive or a
folder containing many files and then download and install all of the required
dependencies. The required dependencies must be available only on the machine performing
the compilation procedure, and if the program is compiled statically, all used libraries,
such as the OpenSSL library, are directly bundled inside the final executable,
at the expense of being larger than a dynamically linked program. Furthermore,
and this is critical, \cite{programming_languages_efficiency} reports that applications
that are implemented with a system programming language and are compiled directly
to machine code are significantly more efficient and demand fewer resources and energy
to accomplish the same result as an interpreted language. I would prefer \texttt{Rust}\footnote{\url{https://www.rust-lang.org}}
over the other two system languages because it guarantees memory safety and thread
safety, increasing overall reliability and productivity, even though it has a steep
learning curve at first, thanks to the various official tools, such as a package
manager and auto formatter. Although the development and effort required by a
compiled language is greater than that required by an interpreted language, the overall
benefits in this circumstance are too significant to be ignored. \\ %
Another area that needs to be enhanced is general error management and node administration,
since there is currently just a simple management of the two that heavily relies
on Kubernetes. Updated versions should improve error alerts to administrators as
well as possible recovery mechanisms. The latter can also be extended to use
various approaches based on the overall circumstances and deployment environment.
\\ %
Undoubtedly, many aspects of the Server could be improved but are not covered in
this section. However, because the project is completely FLOSS compliant, users
can contribute and improve the code with ideas that I hadn't even considered
before.

\section{Closing Remarks}
\label{sec:conclusions_closing_remarks}

Adapting existing tools that are specifically developed for big and energy-hungry
environments to a more sustainable and resource-aware design while maintaining nearly
the same capabilities for the computing industry is not only feasible, but also
necessary for a more sustainable future.